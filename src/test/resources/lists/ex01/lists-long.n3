@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix : <http://www.example.org/ns#> .
#@prefix r: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
 @prefix r: <http://www.example.org#>.

# eye:
#    - @prefix r: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>. --> finds only ':c a :cat.'
#          - no contradiction with: () log:onNegativeSurface {:a a :cat.}.
#    - @prefix r: <http://www.example.org#>. --> finds ':c a :cat.' and ':a a :cat.'
#          --> contradiction with: () log:onNegativeSurface {:a a :cat.}.

# vampire:
#    - @prefix r: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>. --> finds ':a rdf:type :cat.' and ':c rdf:type :cat'.
#    - @prefix r: <http://www.example.org#>. --> finds ':a rdf:type :cat.' and ':c rdf:type :cat'.

# both: without the additional constraints --> find only ':c' solution

# ----> eye doesn't have the functional rdf:first restriction

(_:BN_1 _:BN_2 _:BN_3 _:t) log:onPositiveSurface {

   # as Object
   (_:A _:B _:first _:first1 _:p) log:onNegativeSurface {
      () log:onNegativeSurface {
         _:B _:p _:first1.
      }.
      _:B _:p _:first.
      _:A r:first _:first.
      _:A r:first _:first1.
   }.

   # as Subject
   (_:A _:B _:first _:first1 _:p) log:onNegativeSurface {
      () log:onNegativeSurface {
         _:first1 _:p _:B.
      }.
      _:first _:p _:B.
      _:A r:first _:first.
      _:A r:first _:first1.
   }.

   # as Predicate
   (_:A _:S _:O _:first _:first1) log:onNegativeSurface {
      () log:onNegativeSurface {
         _:S _:first1 _:O.
      }.
      _:S _:first _:O.
      _:A r:first _:first.
      _:A r:first _:first1.
   }.

   # ( :a :b :c )
   _:BN_1 r:first :a.
   _:BN_1 r:rest _:BN_2.
   _:BN_2 r:first :b.
   _:BN_2 r:rest _:BN_3.
   _:BN_3 r:first :c.
   _:BN_3 r:rest r:nil.

   _:BN_1 r:first :c.

   :c <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> :cat.
}.

(_:A _:B) log:onQuerySurface {
    _:A <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> _:B.
}.

